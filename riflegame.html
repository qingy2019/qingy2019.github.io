<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rifle Game</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas">
    <div id="score">Score: 0</div>
</canvas>
<script>
    var scoreCounter = 0;
    document.getElementById('score').textContent = 'Score: ' + scoreCounter;
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    let particles = [];

    // Function to generate particles at a given position
    function createParticles(x, y) {
        const numParticles = 30;
        const angleStep = (2 * Math.PI) / numParticles;

        for (let i = 0; i < numParticles; i++) {
            const angle = i * angleStep;
            const speed = Math.random() * 4 + 2;

            const particle = {
                x: x,
                y: y,
                dx: Math.cos(angle) * speed,
                dy: Math.sin(angle) * speed,
                lifeSpan: 1 // Life span of 1 second
            };

            particles.push(particle);
        }
    }
    const rifleImg = new Image();
    rifleImg.onload = function() {
        init();
    };
    let good =false;
    rifleImg.onerror = function() {
        console.error("Failed to load rifle image.");
    };
    rifleImg.src = 'rifle.png';

    const bulletRadius = 9;
    let bullets = [];

    let bulletsNoHarm = [];
    const bulletSpeed = 20;

    let rifle = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        width: 100,
        height: 50,
        angle: 0
    };

    let ball = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 20,
        dx: 2,
        dy: 2,
        gravity: 0.2,
        dampening: 0.999
    };

    function init() {
        document.addEventListener('mousemove', handleMouseMove);
        draw();
    }
    setInterval(() => {
        // Calculate the angle from the ball to the gun
        const dx = rifle.x - (ball.x+5);
        const dy = rifle.y - (ball.y+5);
        const angle = Math.atan2(dy, dx);

        // Create a new bullet at the edge of the ball in the direction of the gun
        let bullet = {
            x: ball.x + Math.cos(angle) * ball.radius + 5,
            y: ball.y + Math.sin(angle) * ball.radius + 5,
            dx: Math.cos(angle) * bulletSpeed,
            dy: Math.sin(angle) * bulletSpeed,
            visible: true,
            shotByBall: true // Indicate that this bullet was shot by the ball
        };
        bullets.push(bullet);
    }, 1000); // 1000 milliseconds = 1 second
    // setInterval(() => {
    //     if (good) shoot();
    // }, 200); // 1000 milliseconds = 1 second
    let lastTime = false;
    function draw() {
        const ball2 = {
            x: ball.x,
            y: ball.y,
            radius: 20,
            dx: ball.dx,
            dy: ball.dy,
            gravity: ball.gravity,
            dampening: ball.dampening
        };
        let good2 = false;
        let bulletX = rifle.x + Math.cos(rifle.angle) * rifle.width / 2;
        let bulletY = rifle.y + Math.sin(rifle.angle) * rifle.width / 2;
        let angle = rifle.angle;
        for (let t = 0; t < 100; t++) {
            let bullets2 = structuredClone(bullets);
            for (let i = 0; i < bullets2.length; i++) {
                if (bullets2[i].shotByBall) {
                    bullets2[i].visible = true;
                    ctx.beginPath();
                    ctx.arc(bullets2[i].x, bullets2[i].y, bulletRadius, 0, Math.PI * 2);
                    ctx.fillStyle = 'black';
                    ctx.fill();
                    const dx = bullets2[i].x - rifle.x;
                    const dy = bullets2[i].y - rifle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < bulletRadius + rifle.width / 2) {
                        // Bullet hits the gun, end the game
                        alert('Game Over');
                        location.reload();
                    }
                    bullets2[i].x += Math.cos(bullets2[i].angle) * bulletSpeed;
                    bullets2[i].y += Math.sin(bullets2[i].angle) * bulletSpeed;
                } else if (bullets2[i].visible) {
                    ctx.beginPath();
                    ctx.arc(bullets2[i].x, bullets2[i].y, bulletRadius, 0, Math.PI * 2);
                    ctx.fillStyle = 'black';
                    ctx.fill();

                    // Check if bullet hits the ball


                    // Check if bullet hits the ball
                    const dx2 = bullets2[i].x - ball2.x;
                    const dy2 = bullets2[i].y - ball2.y;
                    const distance2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                    if (distance2 < bulletRadius + ball2.radius && bullets2[i].visible && !bullets2[i].shotByBall) {
                        // Bullet hits the ball, adjust ball's velocity accordingly
                        const angle = Math.atan2(dy2, dx2);
                        ball2.dx -= Math.cos(angle) * bulletSpeed * 0.7;
                        ball2.dy -= Math.sin(angle) * bulletSpeed * 0.7;
                        // Make bullet invisible
                        bullets2[i].visible = false;
                        if (!bullets2[i].shotByBall) {
                            bullets2[i].visible = false;
                        }
                    }

                    // Move bullet
                    bullets2[i].x += Math.cos(bullets2[i].angle) * bulletSpeed;
                    bullets2[i].y += Math.sin(bullets2[i].angle) * bulletSpeed;

                    // Remove bullet if it goes out of the canvas
                    if (
                        bullets2[i].x < 0 ||
                        bullets2[i].x > canvas.width ||
                        bullets2[i].y < 0 ||
                        bullets2[i].y > canvas.height
                    ) {
                        bullets2.splice(i, 1);
                        // Adjust index after removing element
                        i--;
                    }
                }
            }
            ball2.dy += ball2.gravity;
            ball2.dy *= ball2.dampening; // Dampen vertical velocity
            ball2.x += ball2.dx;
            ball2.y += ball2.dy;

            // Handle ball collisions with screen boundaries
            if (ball2.x + ball2.radius > canvas.width || ball2.x - ball2.radius < 0) {
                ball2.dx *= -1; // Reverse horizontal direction
            }
            if (ball2.y + ball2.radius > canvas.height) {
                // Prevent the ball from sinking into the ground
                ball2.y = canvas.height - ball2.radius;
                ball2.dy *= -1; // Reverse vertical direction
                ball2.dy *= ball2.dampening; // Dampen vertical velocity
            }
            if (ball2.y - ball2.radius < 0) {
                ball2.dy *= -1; // Reverse vertical direction
            }

            bulletX += Math.cos(angle) * bulletSpeed;
            bulletY += Math.sin(angle) * bulletSpeed;

            // Check if bullet hits the ball
            const dx2 = bulletX - ball2.x;
            const dy2 = bulletY - ball2.y;
            const distance2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
            if (distance2 <= bulletRadius + ball2.radius) {
                good2 = true;
                break
            }
            // bulletsNoHarm.push(bullet);
        }
        good = good2;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Update rifle angle based on mouse position
        const dx = mouseX - rifle.x;
        const dy = mouseY - rifle.y;
        rifle.angle = Math.atan2(dy, dx);

        // Draw rifle
        ctx.save();
        ctx.translate(rifle.x, rifle.y);
        ctx.rotate(rifle.angle);
        ctx.drawImage(rifleImg, -rifle.width / 2, -rifle.height / 2, rifle.width, rifle.height);
        ctx.restore();
        ctx.save();
        ctx.setLineDash([5, 15]); // Set line style to dashed

        if (false) {
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 10;
            // if (!lastTime) shoot();
        }
        else {
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;

        }
        lastTime = good;
        ctx.beginPath();
        ctx.moveTo(rifle.x, rifle.y); // Start at the rifle's position

        // Calculate the distance between the place where the bullets exit the gun and the ball
        const dx2 = ball.x - (rifle.x + Math.cos(rifle.angle) * rifle.width / 2);
        const dy2 = ball.y - (rifle.y + Math.sin(rifle.angle) * rifle.width / 2);
        const distance = Math.sqrt(dx2 * dx2 + dy2 * dy2);

        // Draw a line in the direction where the bullet will go
        // The end point of the line is calculated using the rifle's angle and half of the distance
        ctx.lineTo(rifle.x + Math.cos(rifle.angle) * distance, rifle.y + Math.sin(rifle.angle) * distance);
        ctx.stroke(); // Draw the line
        ctx.restore();

        // Draw ball
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'red';
        ctx.fill();

        // Update ball position
        ball.dy += ball.gravity;
        ball.dy *= ball.dampening; // Dampen vertical velocity
        ball.x += ball.dx;
        ball.y += ball.dy;

        // Handle ball collisions with screen boundaries
        if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
            ball.dx *= -1; // Reverse horizontal direction
        }
        if (ball.y + ball.radius > canvas.height) {
            // Prevent the ball from sinking into the ground
            ball.y = canvas.height - ball.radius;
            ball.dy *= -1; // Reverse vertical direction
            ball.dy *= ball.dampening; // Dampen vertical velocity
        }
        if (ball.y - ball.radius < 0) {
            ball.dy *= -1; // Reverse vertical direction
        }

        // Draw bullets
        for (let i = 0; i < bullets.length; i++) {
            if (bullets[i].shotByBall) {
                bullets[i].visible = true;
                ctx.beginPath();
                ctx.arc(bullets[i].x, bullets[i].y, bulletRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.fill();
                const dx = bullets[i].x - rifle.x;
                const dy = bullets[i].y - rifle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < bulletRadius + rifle.width / 2) {
                    // Bullet hits the gun, end the game
                    alert('Game Over');
                    location.reload();
                }
                bullets[i].x += Math.cos(bullets[i].angle) * bulletSpeed;
                bullets[i].y += Math.sin(bullets[i].angle) * bulletSpeed;
            } else if (bullets[i].visible) {
                ctx.beginPath();
                ctx.arc(bullets[i].x, bullets[i].y, bulletRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.fill();

                // Check if bullet hits the ball


                // Check if bullet hits the ball
                const dx2 = bullets[i].x - ball.x;
                const dy2 = bullets[i].y - ball.y;
                const distance2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                if (distance2 < bulletRadius + ball.radius && bullets[i].visible && !bullets[i].shotByBall) {
                    // Bullet hits the ball, adjust ball's velocity accordingly
                    const angle = Math.atan2(dy2, dx2);
                    ball.dx -= Math.cos(angle) * bulletSpeed * 0.7;
                    ball.dy -= Math.sin(angle) * bulletSpeed * 0.7;
                    scoreCounter++;
                    document.getElementById('score').textContent = 'Score: ' + scoreCounter;
                    createParticles(ball.x, ball.y);
                    // Make bullet invisible
                    bullets[i].visible = false;
                    if (!bullets[i].shotByBall) {
                        bullets[i].visible = false;
                    }
                }

                // Move bullet
                bullets[i].x += Math.cos(bullets[i].angle) * bulletSpeed;
                bullets[i].y += Math.sin(bullets[i].angle) * bulletSpeed;

                // Remove bullet if it goes out of the canvas
                if (
                    bullets[i].x < 0 ||
                    bullets[i].x > canvas.width ||
                    bullets[i].y < 0 ||
                    bullets[i].y > canvas.height
                ) {
                    bullets.splice(i, 1);
                    // Adjust index after removing element
                    i--;
                }
            }
        }
        for (let i = 0; i < bulletsNoHarm.length; i++) {
            ctx.beginPath();
            ctx.arc(bulletsNoHarm[i].x, bulletsNoHarm[i].y, bulletRadius, 0, Math.PI * 2);
            ctx.fillStyle = 'black';
            ctx.fill();
        }
        for (let i = 0; i < particles.length; i++) {
            const particle = particles[i];

            // Update particle position
            particle.x += particle.dx;
            particle.y += particle.dy;

            // Decrease particle life span
            particle.lifeSpan -= 0.02; // Decrease by 0.02 each frame to last about 1 second

            // Remove particle if its life span reaches 0
            if (particle.lifeSpan <= 0) {
                particles.splice(i, 1);
                i--; // Adjust index after removing element
                continue;
            }

            // Draw particle
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, 5, 0, Math.PI * 2);
            // Set color based on life span (transition from yellow to red)
            ctx.fillStyle = `hsl(${particle.lifeSpan * 60}, 100%, 50%)`;
            ctx.fill();
        }

        requestAnimationFrame(draw);
    }

    function shoot() {

        let bullet = {
            x: rifle.x + Math.cos(rifle.angle) * rifle.width / 2,
            y: rifle.y + Math.sin(rifle.angle) * rifle.width / 2,
            angle: rifle.angle,
            visible: true
        };
        bullets.push(bullet);
    }

    function handleMouseMove(event) {
        mouseX = event.clientX - canvas.getBoundingClientRect().left;
        mouseY = event.clientY - canvas.getBoundingClientRect().top;
    }

    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;

    let keys = {
        'w': false,
        'a': false,
        's': false,
        'd': false,
        ' ': false
    };
    document.addEventListener('keydown', (event) => {
        const key = event.key.toLowerCase();
        console.log(key);
        if (key in keys) {
            console.log("test");
            keys[key] = true;
            console.log(keys)
        }
        if (keys['w']) {
            console.log("test333");
            rifle.y -= 5;
        }
        if (keys['s']) {
            rifle.y += 5;
        }
        if (keys['a']) {
            rifle.x -= 5;
        }
        if (keys['d']) {
            rifle.x += 5;
        }
        if (keys[' ']) {
            shoot();
        }
    });

    document.addEventListener('keyup', (event) => {
        const key = event.key.toLowerCase();
        if (key in keys) {
            keys[key] = false;
        }

    });


</script>
</body>
</html>
